2ï¸âƒ£ Collections.reverseOrder() â†’ static factory method

ğŸ“Œ When to use it

When you donâ€™t already have a Comparator
And you want a ready-made reverse comparator

Example
Collections.sort(list, Collections.reverseOrder());


With custom comparator:
Collections.sort(list, Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));

Key points

Belongs to Collections
Returns a new Comparator

Old-school, preâ€“Java-8 style but still valid

1ï¸âƒ£ reversed() â†’ instance method on a Comparator

ğŸ“Œ When to use it

When you already have a Comparator
And you want the opposite order of that same comparator

Example:
Comparator<Integer> cmp = Comparator.naturalOrder();
Comparator<Integer> revCmp = cmp.reversed();


or inline (very common):
list.sort(Comparator.comparing(Employee::getSalary).reversed());

Key points

Works on any Comparator
Keeps the same comparison logic, just flips it
Fluent / chainable (Java 8 style)

| Feature             | `reversed()`        | `Collections.reverseOrder()` |
| ------------------- | ------------------- | ---------------------------- |
| Type                | Instance method     | Static method                |
| Works on            | Existing Comparator | Creates a Comparator         |
| Java version        | Java 8+             | Java 1.2+                    |
| Chaining            | âœ… Yes              | âŒ No                        |
| Interview-preferred | âœ… Yes              | âš ï¸ Acceptable                |

ğŸ§  Rule of thumb (easy to remember)

ğŸ‘‰ Already have a Comparator? â†’ use .reversed()
ğŸ‘‰ Need a Comparator from scratch? â†’ use reverseOrder()

ğŸ’¡ Interview tip (say this and look senior)

â€œreversed() is preferred in modern Java because it preserves comparator intent and
allows fluent composition.â€

So .reversed() , can be used for Integer comparing without Collections . For Collections
you need reversedOrder().